package main

import (
	"fmt"
	"time"
)

var lastPrint = time.Now()
var startTime = time.Now()

// Generated by Ruby code: [1,2,3].repeated_permutation(3).map(&:sum).to_a
// Every time a player "plays", generate these many universes.
var dieRolls = [27]uint8{3, 4, 5, 4, 5, 6, 5, 6, 7, 4, 5, 6, 5, 6, 7, 6, 7, 8, 5, 6, 7, 6, 7, 8, 7, 8, 9}

type Player struct {
	Position uint8
	Score    uint8
}

func (p Player) String() string {
	return fmt.Sprintf("Player{Position: %d, Score: %d}", p.Position, p.Score)
}

type Universe struct {
	Players    [2]Player
	NextPlayer bool // 0 or 1
}

type PlayerPair = [2]Player

var universesWon = [2]uint64{0, 0}

func printUniverses() {
	timeSince := time.Since(lastPrint)
	if timeSince > (time.Second * 2) {
		seconds_elapsed_rounded := int(time.Since(startTime).Seconds())
		minutes_elapsed_rounded := seconds_elapsed_rounded / 60
		fmt.Printf("Universes won: [%d, %d] (elapsed: %d seconds, %d minutes)\n", universesWon[0], universesWon[1], seconds_elapsed_rounded, minutes_elapsed_rounded)
		lastPrint = time.Now()
	}
}

func main() {
	universes := make([]Universe, 0, 1000)
	universes = append(universes, Universe{
		Players: [2]Player{
			{4, 0},
			{8, 0},
		},
		NextPlayer: false,
	})

	newUniverses := make([]Universe, 0, 1000)

	var dieRollUniverses [27]Universe
	var winPair [2]uint64
	type universeAndWinCache struct {
		universes [27]Universe
		winPair   [2]uint64
	}
	var cacheUniverses = map[Universe]universeAndWinCache{}

	for len(universes) > 0 {
		newUniverses = newUniverses[:0]

		for _, universe := range universes {
			// fmt.Printf("Processing universe %v\n", universe)
			printUniverses()
			if cache, ok := cacheUniverses[universe]; ok {
				universesWon[0] += cache.winPair[0]
				universesWon[1] += cache.winPair[1]
				newUniverses = append(newUniverses, cache.universes[:]...)
				// fmt.Println("Using cache")
				continue
			}

			// Build the player index
			playerIndex := 0
			if universe.NextPlayer {
				playerIndex = 1
			}

			player := universe.Players[playerIndex]

			winPair[0] = 0
			winPair[1] = 0
			for i, moves := range dieRolls {
				newPos := (player.Position + moves) % 10
				newScore := player.Score + newPos + 1

				// fmt.Println("Score is", newScore)
				if newScore >= 21 {
					universesWon[playerIndex]++
					winPair[playerIndex]++
					continue
				}

				newUniverse := universe
				newUniverse.NextPlayer = !newUniverse.NextPlayer
				newUniverse.Players[playerIndex] = Player{newPos, newScore}
				dieRollUniverses[i] = newUniverse
			}

			newUniverses = append(newUniverses, dieRollUniverses[:]...)
			cacheUniverses[universe] = universeAndWinCache{dieRollUniverses, winPair}
		}

		newUniverses, universes = universes, newUniverses
	}

	fmt.Printf("Universes won: [%d, %d]\n", universesWon[0], universesWon[1])
}
