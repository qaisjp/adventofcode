package main

import (
	"fmt"
	"time"
)

var lastPrint = time.Now()
var startTime = time.Now()

// Generated by Ruby code: [1,2,3].repeated_permutation(3).map(&:sum).to_a
// Every time a player "plays", generate these many universes.
var dieRolls = [27]uint8{3, 4, 5, 4, 5, 6, 5, 6, 7, 4, 5, 6, 5, 6, 7, 6, 7, 8, 5, 6, 7, 6, 7, 8, 7, 8, 9}

type Player struct {
	Position uint8
	Score    uint8
}

func (p Player) String() string {
	return fmt.Sprintf("Player{Position: %d, Score: %d}", p.Position, p.Score)
}

type Universe struct {
	Players    [2]Player
	NextPlayer bool // 0 or 1
}

type PlayerPair = [2]Player

var universesWon = [2]uint64{0, 0}

type universeAndWinCache struct {
	universes []Universe
	winPair   [2]uint64
}

var cacheUniverses = map[Universe]universeAndWinCache{}
var cacheUses = 0
var cacheUses2 = 0

func printUniverses() {
	timeSince := time.Since(lastPrint)
	if timeSince > (time.Second * 2) {
		seconds_elapsed_rounded := int(time.Since(startTime).Seconds())
		minutes_elapsed_rounded := seconds_elapsed_rounded / 60
		fmt.Printf("Universes won: [%d, %d] (elapsed: %d seconds, %d minutes) - cache size is %d, used %d times (and %d times for the inner loop)\n", universesWon[0], universesWon[1], seconds_elapsed_rounded, minutes_elapsed_rounded, len(cacheUniverses), cacheUses, cacheUses2)
		lastPrint = time.Now()
	}
}

func applyFromCache(universe Universe, newUniverses *[]Universe, secondCounter bool) bool {
	cache, ok := cacheUniverses[universe]
	if !ok {
		return false
	}

	universesWon[0] += cache.winPair[0]
	universesWon[1] += cache.winPair[1]
	*newUniverses = append(*newUniverses, cache.universes...)
	if secondCounter {
		cacheUses2++
	} else {
		cacheUses++
	}
	// fmt.Println("Using cache")
	return true
}

func main() {
	universes := make([]Universe, 0, 1000)
	universes = append(universes, Universe{
		Players: [2]Player{
			{4, 0},
			{8, 0},
		},
		NextPlayer: false,
	})

	newUniverses := make([]Universe, 0, 1000)

	var winPair [2]uint64

	for len(universes) > 0 {
		newUniverses = newUniverses[:0]

		for _, universe := range universes {
			// fmt.Printf("Processing universe %v\n", universe)
			printUniverses()

			if applyFromCache(universe, &newUniverses, false) {
				continue
			}

			// Build the player index
			playerIndex := 0
			if universe.NextPlayer {
				playerIndex = 1
			}

			player := universe.Players[playerIndex]

			winPair[0] = 0
			winPair[1] = 0

			dieRollUniverses := []Universe{}
			for _, moves := range dieRolls {
				newPos := (player.Position + moves) % 10
				newScore := player.Score + newPos + 1

				// fmt.Println("Score is", newScore)
				if newScore >= 21 {
					universesWon[playerIndex]++
					winPair[playerIndex]++
					continue
				}

				newUniverse := universe
				newUniverse.NextPlayer = !newUniverse.NextPlayer
				newUniverse.Players[playerIndex] = Player{newPos, newScore}

				if !applyFromCache(newUniverse, &dieRollUniverses, true) {
					dieRollUniverses = append(dieRollUniverses, newUniverse)
				}
			}

			newUniverses = append(newUniverses, dieRollUniverses...)
			cacheUniverses[universe] = universeAndWinCache{dieRollUniverses, winPair}
		}

		newUniverses, universes = universes, newUniverses
	}

	fmt.Printf("Universes won: [%d, %d]\n", universesWon[0], universesWon[1])
}
